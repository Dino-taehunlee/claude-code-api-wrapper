import { NextRequest } from 'next/server';
import { spawn } from 'child_process';

interface MCPServer {
  name: string;
  transport: 'http' | 'stdio' | 'sse';
  url?: string;
  command?: string;
  args?: string[];
}

// MCP 서버 설정 (예시 - 필요시 추가)
// WebSearch는 Claude Code 내장 도구로 이미 사용 가능
const MCP_SERVERS: MCPServer[] = [
  // 예시: Alpha Vantage (금융 데이터) - API 키 필요
  // { name: 'alphavantage', transport: 'http', url: 'https://mcp.alphavantage.co/mcp?apikey=YOUR_KEY' },
];

interface CustomAgent {
  description: string;
  prompt: string;
  tools?: string[];
  disallowedTools?: string[];
  model?: 'sonnet' | 'opus' | 'haiku' | 'inherit';
  permissionMode?: 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan';
}

const DEFAULT_AGENTS: Record<string, CustomAgent> = {
  'financial-analyst': {
    description: '금융 분석 전문가. 주식, 경제지표, 시장 동향 분석에 사용.',
    prompt: `금융 분석 전문가. 데이터 출처 명시, 리스크 언급, 면책 조항 포함.`,
    tools: ['WebSearch', 'WebFetch'],
    model: 'sonnet'
  }
};

export async function POST(request: NextRequest) {
  const body = await request.json();
  const { prompt, agents, useDefaultAgents = true } = body;

  if (!prompt || typeof prompt !== 'string') {
    return new Response(JSON.stringify({ error: 'Prompt required' }), { status: 400 });
  }

  const claudePath = '/opt/homebrew/bin/claude';
  const args = [
    '--print',
    '--output-format', 'stream-json',
    '--verbose',
    '--model', 'claude-opus-4-5-20251101',  // 최신 Opus 4.5
    '--dangerously-skip-permissions',
  ];

  // MCP 서버 설정
  if (MCP_SERVERS.length > 0) {
    const mcpConfig: Record<string, Record<string, unknown>> = {};
    for (const server of MCP_SERVERS) {
      if (server.transport === 'stdio') {
        mcpConfig[server.name] = {
          transport: 'stdio',
          command: server.command,
          args: server.args || [],
        };
      } else {
        mcpConfig[server.name] = { transport: server.transport, url: server.url || '' };
      }
    }
    args.push('--mcp-config', JSON.stringify(mcpConfig));
  }

  // 에이전트 설정
  const mergedAgents: Record<string, CustomAgent> = {};
  if (useDefaultAgents) Object.assign(mergedAgents, DEFAULT_AGENTS);
  if (agents && typeof agents === 'object') Object.assign(mergedAgents, agents);
  if (Object.keys(mergedAgents).length > 0) {
    args.push('--agents', JSON.stringify(mergedAgents));
  }

  args.push(prompt);

  // ReadableStream으로 스트리밍 응답
  const stream = new ReadableStream({
    start(controller) {
      let isClosed = false;
      const safeClose = () => {
        if (!isClosed) {
          isClosed = true;
          controller.close();
        }
      };

      const child = spawn(claudePath, args, {
        cwd: process.cwd(),
        env: {
          ...process.env,
          PATH: process.env.PATH || '/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin',
          HOME: process.env.HOME || '/root',
          TERM: 'xterm-256color',
        },
        stdio: ['pipe', 'pipe', 'pipe'],
      });

      child.stdin.end();

      let buffer = '';

      child.stdout.on('data', (data) => {
        buffer += data.toString();

        // 줄바꿈으로 분리하여 완전한 JSON 라인만 전송
        const lines = buffer.split('\n');
        buffer = lines.pop() || ''; // 마지막 불완전한 라인은 버퍼에 유지

        for (const line of lines) {
          if (line.trim()) {
            try {
              // JSON 유효성 검사
              JSON.parse(line);
              controller.enqueue(new TextEncoder().encode(line + '\n'));
            } catch {
              // 유효하지 않은 JSON은 무시
            }
          }
        }
      });

      child.stderr.on('data', (data) => {
        console.error('Claude stderr:', data.toString());
      });

      const timeout = setTimeout(() => {
        child.kill();
        controller.enqueue(new TextEncoder().encode(
          JSON.stringify({ type: 'error', message: 'Request timed out' }) + '\n'
        ));
        safeClose();
      }, 1200000); // 20분 타임아웃

      child.on('close', (code) => {
        clearTimeout(timeout);

        // 남은 버퍼 처리
        if (buffer.trim()) {
          try {
            JSON.parse(buffer);
            controller.enqueue(new TextEncoder().encode(buffer + '\n'));
          } catch {
            // 무시
          }
        }

        if (code !== 0) {
          controller.enqueue(new TextEncoder().encode(
            JSON.stringify({ type: 'error', message: `Process exited with code ${code}` }) + '\n'
          ));
        }
        safeClose();
      });

      child.on('error', (err) => {
        clearTimeout(timeout);
        controller.enqueue(new TextEncoder().encode(
          JSON.stringify({ type: 'error', message: err.message }) + '\n'
        ));
        safeClose();
      });
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/plain; charset=utf-8',
      'Transfer-Encoding': 'chunked',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
